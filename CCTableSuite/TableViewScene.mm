////  TableViewScene.m//  CCTable////  Created by Sangwoo Im on 6/4/10.//  Copyright 2010 Sangwoo Im. All rights reserved.//#import "TableViewScene.h"#import "MyCell.h"#import "MyDoubleSizedCell.h"#import "CCTableViewCell.h"#import "CCMultiColumnTableView.h"@implementation TableViewScene+(id)scene {    CCScene *scene;    scene = [CCScene node];    [scene addChild:[TableViewScene node]];    return scene;}-(id)init {    if ((self = [super init])) {        NSAutoreleasePool *pool;        CGSize            winSize, cSize;                pool    = [NSAutoreleasePool new];        cSize   = [MyCell cellSize];        winSize = [[CCDirector sharedDirector] winSize];         vTable  = [[CCTableView tableViewWithDataSource:self size:CGSizeMake(cSize.width+10, winSize.height)] retain];                vTable.direction  = mvTable.direction = CCScrollViewDirectionVertical;        mbTable.direction = CCScrollViewDirectionBoth;                //[[CCSpriteFrameCache sharedSpriteFrameCache] addSpriteFramesWithFile:@"cell.plist"];                vTable.position  = ccp(0.0-10, 0);        vTable.tDelegate = self;        vTable.spriteDelegate = self;        mbTable.colCount = 2;                [self addChild:vTable];              [vTable reloadData];        sprArr = [[NSMutableArray arrayWithCapacity:100] retain];        [pool drain];                CCSprite *deleteButton = [CCSprite spriteWithFile:@"share_delete.png"];        deleteButton.position = ccp(screenSize.width-deleteButton.contentSize.width/2-10,screenSize.height/2);        [self addChild:deleteButton z:1 tag:300];                [self registerWithTouchDispatcher];    }    return self;}-(void)registerWithTouchDispatcher{    [[CCTouchDispatcher sharedDispatcher] addStandardDelegate:self priority:-1];}- (void)selectSpriteForTouch:(CGPoint)touchLocation {    for (CCSprite *sprite in sprArr) {        if (CGRectContainsPoint(sprite.boundingBox, touchLocation)) {            CGPoint loacl = [sprite convertToNodeSpace:touchLocation];            if (![Common isTransparentWithSprite:sprite pointInNodeSpace:loacl onto:(CCLayer*)self]) {                focusSpr = sprite;            }            //focusSpr.position = touchLocation;            continue;        }    } }-(void)panForTranslation:(CGPoint)translation {    if (focusSpr) {        CGPoint newPos = ccpAdd(focusSpr.position, translation);        double retvalY=focusSpr.position.y;        double retvalX=focusSpr.position.x;                //        retvalY = MIN(retvalY, screenSize.height);        //        retvalY = MAX(retvalY, 440);         //                //        retvalX = MIN(retvalX, 510);        //        retvalX = MAX(retvalX, 0);                 focusSpr.position = ccp(retvalX,retvalY);             focusSpr.position = newPos;            }}- (void) ccTouchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{    //[super ccTouchesBegan:touches withEvent:event];	//CCSprite *watter = (CCSprite*)[rabbit getChildByTag:100];	UITouch *touch = [touches anyObject];	CGPoint rightPosition = [self convertTouchToNodeSpace:touch];    [self selectSpriteForTouch:rightPosition];    }-(void) ccTouchesMoved:(NSSet *)touches withEvent:(UIEvent *)event{    	UITouch *touch = [touches anyObject];    CGPoint rightPosition = [self convertTouchToNodeSpace:touch];	CGPoint oldTouchLocation = [touch previousLocationInView:touch.view];    oldTouchLocation = [[CCDirector sharedDirector] convertToGL:oldTouchLocation];    oldTouchLocation = [self convertToNodeSpace:oldTouchLocation];        CGPoint translation  = ccpSub(rightPosition,oldTouchLocation);    [self panForTranslation:translation];}-(void) ccTouchesEnded:(NSSet *)touches withEvent:(UIEvent *)event{        CCSprite *del = (CCSprite*)[self getChildByTag:300];        if (focusSpr && CGRectContainsRect(focusSpr.boundingBox, del.boundingBox)) {               id a1 = [CCMoveTo actionWithDuration:0.2 position:del.position];        id a2 = [CCScaleTo actionWithDuration:0.2 scale:0];        id ap = [CCSpawn actions:a1,a2, nil];        [focusSpr runAction:[CCSequence actions:ap,[CCCallBlock actionWithBlock:BCA(^(void){            [sprArr removeObject:focusSpr];            [self removeChild:focusSpr cleanup:YES];        })], nil]];    }    focusSpr = nil;    }-(void)scale:(UIPinchGestureRecognizer *)recognizer{    if(recognizer.state == UIGestureRecognizerStateBegan) {          CGPoint touchLocation = [recognizer locationInView:recognizer.view];        touchLocation = [[CCDirector sharedDirector] convertToGL:touchLocation];        touchLocation = [self convertToNodeSpace:touchLocation];        [self selectSpriteForTouch:touchLocation];        _lastScale = 1.0;      }          float scale =  - (_lastScale - [recognizer scale]);      CCLOG(@"scale%f",scale);    //CGAffineTransform currentTransform = photoImage.transform;      //CGAffineTransform newTransform = CGAffineTransformScale(currentTransform, scale,     focusSpr.scale += scale;    focusSpr.scale = MIN(focusSpr.scale,2);    focusSpr.scale = MAX(focusSpr.scale,0.5);    _lastScale = [recognizer scale];      //[self showOverlayWithFrame:photoImage.frame];}-(void)rotate:(UIRotationGestureRecognizer *)recognizer{     if([recognizer state] == UIGestureRecognizerStateEnded) {                  _lastRotation = 0.0;          return;      }      CGPoint touchLocation = [recognizer locationInView:recognizer.view];    touchLocation = [[CCDirector sharedDirector] convertToGL:touchLocation];    touchLocation = [self convertToNodeSpace:touchLocation];    [self selectSpriteForTouch:touchLocation];    CGFloat rotation = 0.0 - (_lastRotation - [recognizer rotation]);      CCLOG(@"rot %f",rotation);    focusSpr.rotation += rotation*180/M_PI;    _lastRotation = [recognizer rotation]; }#pragma mark -#pragma mark TableView Delegate-(void)table:(CCTableView *)table cellTouched:(CCTableViewCell *)cell {    CCLOG(@"cell touched at index: %i", cell.idx);}-(void)table:(CCTableView *)table cellTouchedBegin:(CCTableViewCell *)cell {    CCLOG(@"cell Begin at index: %i", cell.idx);}-(void)table:(CCTableView *)table cellTouchedMoved:(CCTableViewCell *)cell POS:(CGPoint)p {    CCLOG(@"cell Moved at index: %i", cell.idx);    if (focusSpr!=nil) {        focusSpr.position = p;    }}#pragma mark -#pragma mark TableView DataSource-(Class)cellClassForTable:(CCTableView *)table {    if (table == mbTable) {        return [MyDoubleSizedCell class];    }    return [MyCell class];}-(CCTableViewCell *)table:(CCTableView *)table cellAtIndex:(NSUInteger)idx {    CCTableViewCell *cell;    NSString        *spriteName;    CCSprite        *sprite;        cell       = [table dequeueCell];    spriteName = [NSString stringWithFormat:@"p_%i.png", idx%15+1];    sprite     = [CCSprite spriteWithFile:spriteName];    if (!cell) {        if (table == mbTable) {            cell = [[MyDoubleSizedCell new] autorelease];        } else {            cell = [[MyCell new] autorelease];        }    }    cell.node = sprite;     sprite.scale = 0.8;    if (table == mbTable) {        sprite.scale *= 2;    }    return cell;}-(NSUInteger)numberOfCellsInTableView:(CCTableView *)table {    return 15;}-(void) dealloc {    [mbTable release];    [hTable  release];    [vTable  release];    [mhTable release];    [mvTable release];    [sprArr  release];    [super   dealloc];    [[CCSpriteFrameCache sharedSpriteFrameCache] removeUnusedSpriteFrames];}#pragma mark -#pragma mark TableView spriteDelegate-(void)table:(CCTableView *)table selected:(CCTableViewCell *)cell{    CCSprite *sp = [CCSprite spriteWithFile:[NSString stringWithFormat:@"p_%d.png",cell.idx+1]];    [self addChild:sp z:1];    sp.scale = 1.1;    sp.position = ccpAdd(cell.node.position, ccp([MyCell cellSize].width/2,[MyCell cellSize].height/2));        //[sprArr insertObject:sp atIndex:0];    [sprArr addObject:sp];    focusSpr = sp;}-(void)table:(CCTableView *)table unselected:(CCTableViewCell *)cell{    focusSpr.scale = 0.8;}-(void)cancelAllSp{    for (CCSprite *sp in sprArr) {        if (sp==focusSpr) {            focusSpr = nil;        }        [self removeChild:sp cleanup:YES];    }    }@end